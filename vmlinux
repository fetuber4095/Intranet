#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
#  vmlinux
#  
#  Copyright 2023 Felipe Souza <fetuber4095@Tardis>
#  
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#  
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#  
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
#  MA 02110-1301, USA.
#  
#  

from os import system, chdir, listdir, getcwd
from getpass import getpass as pinentry
from time import sleep as wait
from random import randint, choice
from sys import exit as close
from sys import argv

import os
import json
import time
import random
import socket
import shutil
import platform
import http.server
import socketserver
import urllib.request


class consoleApplication:
	def __init__(self):
		with open("etc/vmlinux.json", "r") as cache:
			self.vmlinux = json.load(cache)
			
		self.appname = self.vmlinux['appname']
		self.version = self.vmlinux['version']
		
		self.hostname = socket.gethostname()
		self.ipv4 = socket.gethostbyname(self.hostname)
		self.port = randint(1000, 9999)
		
		self.system = platform.system().lower()
		self.root = getcwd()
		self.run = 1
		self.aliases = self.vmlinux['alias']
		
		self.globals = {
			"os": os, "json": json, "socket": socket, "shutil": shutil,
			"http": http, "socketserver": socketserver, "time": time,
			"urllib": urllib, "random": random, "platform": platform,
			
			"clear": self.clear, "runtime": self.runtime,
			"terminal": self.terminal, "busybox": self.Busybox, 
			"wget": self.download, "recognize": self.recognize,
			"replace": self.replace,
			
			"wait": wait, "argv": argv, "randint": randint,
			"choice": choice, "pinentry": pinentry, "local": system, 
			"appname": self.appname, "version": self.version,
			"hostname": self.hostname, "ipv4": self.ipv4, "port": self.port,
			"system": self.system, "root": self.root, "rem": [],
			"vmlinux": self.vmlinux
		}
		self.locals = {}
		
	def connect(self, host):
		for driver in self.vmlinux['drivers']: self.runtime(driver)
		for script in self.vmlinux['autorun']: self.runtime(script)
		
		return True	
	def download(self, url, output_file):
		try:
			urllib.request.urlretrieve(url, output_file)
			
			return True
		except Exception as e: return False
	def runtime(self, program, command=""):
		if program.startswith("/"): program = f"{self.root}{program}"
		exec(f"cmd = '{command}'", self.globals, self.locals)
		
		try:
			with open(program, "r") as cache:
				exec(cache.read(), self.globals, self.locals)
				
				return True
		except IsADirectoryError: return False
	def terminal(self, console="cons0"):
		while True:
			try: 
				command = input(f"\n# ").strip()
				command = command.replace(" ", "?&@111").replace("|", " ").split()
				for cmd in command: self.Busybox(cmd.replace("?&@111", " "))
			except KeyboardInterrupt: self.clear()
			except EOFError: close()
			
			self.run = self.run + 1
	
	def Busybox(self, command):
		try:
			cmd = str(self.recognize(command)).strip()
			
			if cmd.startswith("."):
				cmd = ' '.join(cmd.split()[1:])
				
				if cmd != "": self.runtime(cmd)
				else: print(f"{self.appname.lower()}: no scripts to run")
			elif cmd.startswith(":"):
				try: exec(' '.join(cmd.split()[1:]), self.globals, self.locals)
				except Exception as traceback: print(traceback)
			elif cmd.startswith("exit"): close()
			elif cmd.startswith("dir"): system(cmd)
			elif cmd.startswith("clear"): self.clear()
			elif cmd.startswith("nano"):
				if self.system != "windows": system(cmd)
				else: print(f"{self.appname.lower()}: nano: envirronment error")
			
			elif cmd.startswith("true"): return True
			elif cmd.startswith("false"): return False
			
			elif cmd.startswith("alias"):
				cmd = ' '.join(cmd.split()[1:])
				
				if cmd != "":
					try: 
						alias_name = cmd.split()[0]
						alias_func = cmd.split()[1:]
												
						self.aliases[alias_name] = ' '.join(alias_func)
					except IndexError: print(f"{self.appname.lower()}: alias: use [name[=value]] to alias it")
				else:
					for alias in self.aliases: print(f"alias {alias}='{self.aliases[alias]}'")
			elif cmd.startswith("unalias"):
				cmd = ' '.join(cmd.split()[1:])
				
				if cmd != "":
					if cmd in self.aliases: del self.aliases[cmd]
					else: print(f"{self.appname.lower()}: unalias: not defined")
			elif cmd.startswith("builtin"):
				cmd = ' '.join(cmd.split()[1:])
		
				if cmd != "":
					if cmd.split()[0] in listdir(f"{self.root}/etc"): self.runtime(f"/etc/{cmd.split()[0]}", ' '.join(cmd.split()[1:]))
					else: print(f"{self.appname.lower()}: builtin: {cmd.split()[0]}: not found")
				else: print(f"{self.appname.lower()}: {self.run}: builtin based on GNU\Linux (Coreutils)")
			
			else:
				if cmd != "":
					if cmd.split()[0] in listdir(): self.runtime(cmd.split()[0], ' '.join(cmd.split()[1:]))
					
					elif cmd.split()[0] in self.aliases: self.Busybox(f"{self.aliases[cmd.split()[0]]} {' '.join(cmd.split()[1:])}")	
					elif cmd.split()[0] in listdir(f"{self.root}/proc"): self.runtime(f"/proc/{cmd.split()[0]}", ' '.join(cmd.split()[1:]))
					elif cmd.split()[0] in listdir(f"{self.root}/proc/lib"): self.runtime(f"/proc/lib/{cmd.split()[0]}", ' '.join(cmd.split()[1:]))
										
					else: print(f"{self.appname.lower()}: {self.run}: {cmd.split()[0]}: not found")
		except KeyboardInterrupt: return 
		except EOFError: return False
		except FileNotFoundError: print(f"{self.appname.lower()}: {self.run}: file not found")
		except IsADirectoryError: print(f"{self.appname.lower()}: {self.run}: is a directory")
		except NotADirectoryError: print(f"{self.appname.lower()}: {self.run}: not a directory")
		except OSError: print(f"{self.appname.lower()}: {self.run}: local: permission denied")
		except Exception as traceback: print(f"{self.appname.lower()}: {self.run}: an unhandled exception occured [{traceback}]")

	def clear(self):
		if "windows" in self.system: system("cls")
		else: system("clear")
	def replace(self, text, command="", new_value=""): return self.recognize(text.replace(f"{command} ", "").replace(f"{command}", ""))
	def recognize(self, text):
		values = {
			"&appname": self.appname, "&version": self.version,
			"&hostname": self.hostname, "&ipv4": self.ipv4, "&port": self.port,
			"&system": self.system, "&root": self.root, "&run": self.run, "&path": getcwd(),
			
			"&green": "\033[32m", "&red": "\033[31m", "&white": "\033[38m", "&blue": "\033[34m",
			"&pink": "\033[35m", "&cian": "\033[36m", "&orange": "\033[33m"
		}
		for word in values: text = text.replace(word, str(values[word]))
		
		return text
	
	
if __name__ == "__main__":
	app = consoleApplication()
	
	app.connect(f"http://localhost:{app.port}")
	app.terminal()
	
